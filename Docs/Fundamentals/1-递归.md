# 递归

## 什么是递归？
   递归（Recursion）指函数的定义中使用函数自身的方法，实际上递归的思想包括递和归，可理解为传递和归来；
   
## 递归通俗的理解：
   递归顾名思义就是有去（递去）有回（归来）。你有一把钥匙，当你打开一扇门，进去后看到还有一扇门，这时你在用手中的钥匙去开这扇门，发现有打开了，进门有又是同样的场景，若干次后，当你在去打开后看到里面就只有一间无门的房子，然后你开始原路返回，每经过一扇门，你就用小本本记录一下，直到回到当时的入口，你就可以回答出手中的钥匙一共开了多少门。  
   与此类比的就是循环：当你用钥匙打开所有门后，你会得到打开门的答案，但是你不会走回头路，入口处的人始终等不到你回去告诉他答案。
   
## 用数学模型理解递归
   通过对递归的理解我们发现递归的数学模型类似 ***数学归纳法*** ，数学归纳法是递归的数学基础;  
   数学归纳法，语义上虽有"归纳"，但其并非以不严谨的归纳推理而是以严谨的**演绎推理法**。数学归纳法用于将给定的原命题化为解决其局部命题（子命题），其子命题有可以继续拆分，而在解决各个命题时我们发现其从起始命题开始到每个子命题其解决模型是一样的，也就是说存在相同的归纳处理逻辑。
   
## 递归的条件
   - 明确递归终止条件；
   - 给出递归终止时的处理方法；
   - 提取重复逻辑，缩小问题规模。  
   
## 递归的算法模型
   - 模型1：在递去的过程中解决问题
   ```java
public T recursion(大规模){
    if(end_condition){  //明确的递归终止条件
        end;
    }else{   //将问题转换为子问题的每一步，解决该步中剩余部分问题
        solve;  //递出
        recursion(小规模);  //传递到最深处，不断归来
    }
}
   ```
  - 模型2：在归来的过程中解决问题
  ```java
public T recursion(大规模){
    if(end_condition){  //明确的递归终止条件
        end;
    }else{   //将问题全部描述展开，再由尽头"返回"依次解决每步剩余部分问题
        recursion(小规模);  //递去
        solve;  //归来
    }
}
```
  
## 递归应用场景
递归算法一般解决三类问题：  
- 问题的定义是按递归定义的 （Fibonacci函数，阶乘...）；
- 问题的解法是递归的（有些问题只能递归解决，如汉诺塔问题...）；
- 数据结构是递归的 （链表、树等的操作，包括树的遍历，树的深度...）